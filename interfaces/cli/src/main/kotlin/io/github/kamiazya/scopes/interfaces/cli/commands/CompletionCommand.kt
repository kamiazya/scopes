package io.github.kamiazya.scopes.interfaces.cli.commands

import com.github.ajalt.clikt.core.CliktCommand
import io.github.kamiazya.scopes.interfaces.cli.adapters.ScopeCommandAdapter
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject

/**
 * Hidden command for providing shell completion candidates.
 *
 * This command outputs completion candidates for aspects, which can be used
 * by shell completion scripts generated by Clikt.
 */
class CompletionCommand :
    CliktCommand(
        name = "_complete-aspects",
        help = "Internal command for shell completion (hidden)",
        hidden = true,
    ),
    KoinComponent {

    private val scopeCommandAdapter: ScopeCommandAdapter by inject()

    override fun run() {
        runBlocking {
            // Get all scopes to collect their aspects
            scopeCommandAdapter.listRootScopes().fold(
                {
                    // On error, output nothing (silent failure for completion)
                },
                { scopes ->
                    // Collect all unique aspect key:value pairs
                    val aspectPairs = mutableSetOf<String>()

                    scopes.forEach { scope ->
                        scope.aspects.forEach { (key, values) ->
                            values.forEach { value ->
                                aspectPairs.add("$key:$value")
                            }
                        }
                    }

                    // Also check children of root scopes in parallel
                    coroutineScope {
                        val jobs = scopes.map { rootScope ->
                            async {
                                scopeCommandAdapter.listChildren(rootScope.id)
                            }
                        }
                        jobs.awaitAll().forEach { result ->
                            result.fold(
                                { /* ignore errors */ },
                                { children ->
                                    children.forEach { child ->
                                        child.aspects.forEach { (key, values) ->
                                            values.forEach { value ->
                                                aspectPairs.add("$key:$value")
                                            }
                                        }
                                    }
                                },
                            )
                        }
                    }

                    // Output each aspect pair on a new line for shell completion
                    aspectPairs.sorted().forEach { pair ->
                        echo(pair)
                    }
                },
            )
        }
    }
}
