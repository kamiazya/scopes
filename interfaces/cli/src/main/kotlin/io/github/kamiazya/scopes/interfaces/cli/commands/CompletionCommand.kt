package io.github.kamiazya.scopes.interfaces.cli.commands

import com.github.ajalt.clikt.core.CliktCommand
import io.github.kamiazya.scopes.interfaces.cli.adapters.ScopeQueryAdapter
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject

/**
 * Hidden command for providing shell completion candidates.
 *
 * This command outputs completion candidates for aspects, which can be used
 * by shell completion scripts generated by Clikt.
 *
 * Note: Error handling uses CliktError for consistency.
 */
class CompletionCommand :
    CliktCommand(
        name = "_complete-aspects",
        help = "Internal command for shell completion (hidden)",
        hidden = true,
    ),
    KoinComponent {

    private val scopeQueryAdapter: ScopeQueryAdapter by inject()

    companion object {
        private const val PAGE_LIMIT = 1000
        private const val INITIAL_OFFSET = 0
        private const val CONCURRENCY_LIMIT = 8
    }

    override fun run() {
        runBlocking {
            val aspectPairs = mutableSetOf<String>()

            // Collect aspects from all scopes (roots + children)
            val rootScopes = fetchAllRootScopes()
            collectAspectsFromRootScopes(rootScopes, aspectPairs)
            collectAspectsFromChildScopes(rootScopes, aspectPairs)

            // Output completion candidates
            outputCompletionCandidates(aspectPairs)
        }
    }

    private suspend fun fetchAllRootScopes(): List<io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult> {
        val rootScopes = mutableListOf<io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult>()
        var offset = INITIAL_OFFSET

        while (true) {
            val page = scopeQueryAdapter
                .listRootScopes(offset = offset, limit = PAGE_LIMIT)
                .fold({ null }, { it }) ?: break

            val items = page.scopes
            if (items.isEmpty()) break

            rootScopes.addAll(items)
            if (items.size < PAGE_LIMIT) break
            offset += PAGE_LIMIT
        }

        return rootScopes
    }

    private fun collectAspectsFromRootScopes(
        rootScopes: List<io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult>,
        aspectPairs: MutableSet<String>,
    ) {
        rootScopes.forEach { scope ->
            extractAspectsFromScope(scope, aspectPairs)
        }
    }

    private suspend fun collectAspectsFromChildScopes(
        rootScopes: List<io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult>,
        aspectPairs: MutableSet<String>,
    ) {
        coroutineScope {
            val semaphore = Semaphore(CONCURRENCY_LIMIT)
            val jobs = rootScopes.map { rootScope ->
                async {
                    semaphore.withPermit {
                        fetchAspectsFromChildren(rootScope)
                    }
                }
            }
            jobs.awaitAll().forEach { localPairs ->
                aspectPairs.addAll(localPairs)
            }
        }
    }

    private suspend fun fetchAspectsFromChildren(rootScope: io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult): Set<String> {
        val localPairs = mutableSetOf<String>()
        var childOffset = INITIAL_OFFSET

        while (true) {
            val childPage = scopeQueryAdapter
                .listChildren(rootScope.id, offset = childOffset, limit = PAGE_LIMIT)
                .fold({ null }, { it }) ?: break

            val children = childPage.scopes
            if (children.isEmpty()) break

            children.forEach { child ->
                extractAspectsFromScope(child, localPairs)
            }

            if (children.size < PAGE_LIMIT) break
            childOffset += PAGE_LIMIT
        }

        return localPairs
    }

    private fun extractAspectsFromScope(scope: io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult, aspectPairs: MutableSet<String>) {
        scope.aspects.forEach { (key, values) ->
            values.forEach { value ->
                aspectPairs.add("$key:$value")
            }
        }
    }

    private fun outputCompletionCandidates(aspectPairs: Set<String>) {
        aspectPairs.sorted().forEach { pair ->
            echo(pair)
        }
    }
}
