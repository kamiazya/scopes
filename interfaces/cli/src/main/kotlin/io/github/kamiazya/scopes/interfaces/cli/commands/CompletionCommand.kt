package io.github.kamiazya.scopes.interfaces.cli.commands

import com.github.ajalt.clikt.core.CliktCommand
import io.github.kamiazya.scopes.interfaces.cli.adapters.ScopeCommandAdapter
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject

/**
 * Hidden command for providing shell completion candidates.
 *
 * This command outputs completion candidates for aspects, which can be used
 * by shell completion scripts generated by Clikt.
 */
class CompletionCommand :
    CliktCommand(
        name = "_complete-aspects",
        help = "Internal command for shell completion (hidden)",
        hidden = true,
    ),
    KoinComponent {

    private val scopeCommandAdapter: ScopeCommandAdapter by inject()

    override fun run() {
        runBlocking {
            // Collect unique aspect key:value pairs across all scopes (roots + children)
            val aspectPairs = mutableSetOf<String>()

            // Page through all root scopes to avoid missing candidates
            val pageLimit = 1000
            var offset = 0
            val rootScopes = mutableListOf<io.github.kamiazya.scopes.contracts.scopemanagement.results.ScopeResult>()

            while (true) {
                val page = scopeCommandAdapter
                    .listRootScopes(offset = offset, limit = pageLimit)
                    .fold({ null }, { it }) ?: break

                val items = page.scopes
                if (items.isEmpty()) break

                rootScopes.addAll(items)
                if (items.size < pageLimit) break
                offset += pageLimit
            }

            // Extract aspects from root scopes
            rootScopes.forEach { scope ->
                scope.aspects.forEach { (key, values) ->
                    values.forEach { value ->
                        aspectPairs.add("$key:$value")
                    }
                }
            }

            // Also extract from children of each root scope with capped concurrency
            coroutineScope {
                val semaphore = Semaphore(8)
                val jobs = rootScopes.map { rootScope ->
                    async {
                        semaphore.withPermit {
                            val localPairs = mutableSetOf<String>()
                            var childOffset = 0
                            while (true) {
                                val childPage = scopeCommandAdapter
                                    .listChildren(rootScope.id, offset = childOffset, limit = pageLimit)
                                    .fold({ null }, { it }) ?: break
                                val children = childPage.scopes
                                if (children.isEmpty()) break

                                children.forEach { child ->
                                    child.aspects.forEach { (key, values) ->
                                        values.forEach { value ->
                                            localPairs.add("$key:$value")
                                        }
                                    }
                                }

                                if (children.size < pageLimit) break
                                childOffset += pageLimit
                            }
                            localPairs
                        }
                    }
                }
                jobs.awaitAll().forEach { local -> aspectPairs.addAll(local) }
            }

            // Output each aspect pair on a new line for shell completion
            aspectPairs.sorted().forEach { pair ->
                echo(pair)
            }
        }
    }
}
