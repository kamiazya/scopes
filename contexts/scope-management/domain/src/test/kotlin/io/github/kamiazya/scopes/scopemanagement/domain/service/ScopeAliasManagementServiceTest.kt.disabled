package io.github.kamiazya.scopes.scopemanagement.domain.service

import arrow.core.left
import arrow.core.right
import io.github.kamiazya.scopes.scopemanagement.domain.entity.ScopeAlias
import io.github.kamiazya.scopes.scopemanagement.domain.error.ScopeAliasError
import io.github.kamiazya.scopes.scopemanagement.domain.repository.ScopeAliasRepository
import io.github.kamiazya.scopes.scopemanagement.domain.valueobject.AliasName
import io.github.kamiazya.scopes.scopemanagement.domain.valueobject.AliasType
import io.github.kamiazya.scopes.scopemanagement.domain.valueobject.ScopeId
import io.kotest.assertions.arrow.core.shouldBeLeft
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import io.mockk.slot

class ScopeAliasManagementServiceTest :
    DescribeSpec({
        describe("ScopeAliasManagementService") {
            val repository = mockk<ScopeAliasRepository>()
            val aliasGenerator = mockk<AliasGenerationService>()
            val service = ScopeAliasManagementService(repository, aliasGenerator)

            val scopeId = ScopeId.generate()
            val aliasName = AliasName.create("test-alias").getOrNull()!!

            beforeEach {
                // Reset mocks before each test
                io.mockk.clearMocks(repository, aliasGenerator)
            }

            describe("assignCanonicalAlias") {
                it("should assign canonical alias when no canonical exists") {
                    val generatedName = AliasName.create("generated-alias").getOrNull()!!
                    val aliasSlot = slot<ScopeAlias>()

                    coEvery { repository.findCanonicalByScopeId(scopeId) } returns null.right()
                    coEvery { aliasGenerator.generate() } returns generatedName.right()
                    coEvery { repository.existsByAliasName(generatedName) } returns false.right()
                    coEvery { repository.save(capture(aliasSlot)) } answers { aliasSlot.captured.right() }

                    val result = service.assignCanonicalAlias(scopeId)

                    result.shouldBeRight()
                    val savedAlias = aliasSlot.captured
                    savedAlias.scopeId shouldBe scopeId
                    savedAlias.aliasName shouldBe generatedName
                    savedAlias.aliasType shouldBe AliasType.CANONICAL

                    coVerify(exactly = 1) { repository.save(any()) }
                }

                it("should replace existing canonical alias") {
                    val existingCanonical = ScopeAlias.createCanonical(scopeId, aliasName)
                    val newGeneratedName = AliasName.create("new-generated").getOrNull()!!
                    val saveSlot = slot<ScopeAlias>()
                    val removeSlot = slot<AliasName>()

                    coEvery { repository.findCanonicalByScopeId(scopeId) } returns existingCanonical.right()
                    coEvery { aliasGenerator.generate() } returns newGeneratedName.right()
                    coEvery { repository.existsByAliasName(newGeneratedName) } returns false.right()
                    coEvery { repository.save(capture(saveSlot)) } answers { saveSlot.captured.right() }
                    coEvery { repository.removeByAliasName(capture(removeSlot)) } returns Unit.right()

                    val result = service.assignCanonicalAlias(scopeId)

                    result.shouldBeRight()
                    val savedAlias = saveSlot.captured
                    savedAlias.scopeId shouldBe scopeId
                    savedAlias.aliasName shouldBe newGeneratedName
                    savedAlias.aliasType shouldBe AliasType.CANONICAL

                    removeSlot.captured shouldBe aliasName

                    coVerify(exactly = 1) { repository.removeByAliasName(aliasName) }
                    coVerify(exactly = 1) { repository.save(any()) }
                }

                it("should retry generation when alias already exists") {
                    val firstGenerated = AliasName.create("taken-alias").getOrNull()!!
                    val secondGenerated = AliasName.create("available-alias").getOrNull()!!
                    val aliasSlot = slot<ScopeAlias>()

                    coEvery { repository.findCanonicalByScopeId(scopeId) } returns null.right()
                    coEvery { aliasGenerator.generate() } returnsMany listOf(
                        firstGenerated.right(),
                        secondGenerated.right(),
                    )
                    coEvery { repository.existsByAliasName(firstGenerated) } returns true.right()
                    coEvery { repository.existsByAliasName(secondGenerated) } returns false.right()
                    coEvery { repository.save(capture(aliasSlot)) } answers { aliasSlot.captured.right() }

                    val result = service.assignCanonicalAlias(scopeId)

                    result.shouldBeRight()
                    aliasSlot.captured.aliasName shouldBe secondGenerated

                    coVerify(exactly = 2) { aliasGenerator.generate() }
                    coVerify(exactly = 2) { repository.existsByAliasName(any()) }
                }

                it("should fail after maximum retries") {
                    val generatedName = AliasName.create("always-taken").getOrNull()!!

                    coEvery { repository.findCanonicalByScopeId(scopeId) } returns null.right()
                    coEvery { aliasGenerator.generate() } returns generatedName.right()
                    coEvery { repository.existsByAliasName(generatedName) } returns true.right()

                    val result = service.assignCanonicalAlias(scopeId)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe ScopeAliasError.AliasGenerationFailed(
                        "Failed to generate unique alias after 10 attempts",
                    )

                    coVerify(exactly = 10) { aliasGenerator.generate() }
                    coVerify(exactly = 10) { repository.existsByAliasName(any()) }
                }
            }

            describe("createCustomAlias") {
                it("should create custom alias when name is available") {
                    val aliasSlot = slot<ScopeAlias>()

                    coEvery { repository.existsByAliasName(aliasName) } returns false.right()
                    coEvery { repository.save(capture(aliasSlot)) } answers { aliasSlot.captured.right() }

                    val result = service.createCustomAlias(scopeId, aliasName)

                    result.shouldBeRight()
                    val savedAlias = aliasSlot.captured
                    savedAlias.scopeId shouldBe scopeId
                    savedAlias.aliasName shouldBe aliasName
                    savedAlias.aliasType shouldBe AliasType.CUSTOM
                }

                it("should fail when alias name already exists") {
                    coEvery { repository.existsByAliasName(aliasName) } returns true.right()

                    val result = service.createCustomAlias(scopeId, aliasName)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe ScopeAliasError.AliasAlreadyExists(aliasName.value)

                    coVerify(exactly = 0) { repository.save(any()) }
                }
            }

            describe("removeAlias") {
                it("should remove custom alias") {
                    val customAlias = ScopeAlias.createCustom(scopeId, aliasName)

                    coEvery { repository.findByAliasName(aliasName) } returns customAlias.right()
                    coEvery { repository.removeByAliasName(aliasName) } returns Unit.right()

                    val result = service.removeAlias(aliasName)

                    result.shouldBeRight()
                    coVerify(exactly = 1) { repository.removeByAliasName(aliasName) }
                }

                it("should fail when trying to remove canonical alias") {
                    val canonicalAlias = ScopeAlias.createCanonical(scopeId, aliasName)

                    coEvery { repository.findByAliasName(aliasName) } returns canonicalAlias.right()

                    val result = service.removeAlias(aliasName)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe ScopeAliasError.CannotRemoveCanonicalAlias(aliasName.value)

                    coVerify(exactly = 0) { repository.removeByAliasName(any()) }
                }

                it("should fail when alias not found") {
                    coEvery { repository.findByAliasName(aliasName) } returns null.right()

                    val result = service.removeAlias(aliasName)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe ScopeAliasError.AliasNotFound(aliasName.value)
                }
            }

            describe("setCanonicalAlias") {
                it("should set existing custom alias as canonical") {
                    val customAlias = ScopeAlias.createCustom(scopeId, aliasName)
                    val existingCanonical = ScopeAlias.createCanonical(
                        scopeId,
                        AliasName.create("old-canonical").getOrNull()!!,
                    )
                    val updateSlot = slot<ScopeAlias>()

                    coEvery { repository.findByAliasName(aliasName) } returns customAlias.right()
                    coEvery { repository.findCanonicalByScopeId(scopeId) } returns existingCanonical.right()
                    coEvery { repository.update(capture(updateSlot)) } answers { updateSlot.captured.right() }

                    val result = service.setCanonicalAlias(aliasName)

                    result.shouldBeRight()

                    // Should update both aliases
                    coVerify(exactly = 2) { repository.update(any()) }

                    val updates = updateSlot.allValues
                    updates.size shouldBe 2

                    // Old canonical should become custom
                    val oldCanonicalUpdate = updates.find { it.id == existingCanonical.id }
                    oldCanonicalUpdate?.aliasType shouldBe AliasType.CUSTOM

                    // Custom should become canonical
                    val newCanonicalUpdate = updates.find { it.id == customAlias.id }
                    newCanonicalUpdate?.aliasType shouldBe AliasType.CANONICAL
                }

                it("should do nothing if alias is already canonical") {
                    val canonicalAlias = ScopeAlias.createCanonical(scopeId, aliasName)

                    coEvery { repository.findByAliasName(aliasName) } returns canonicalAlias.right()

                    val result = service.setCanonicalAlias(aliasName)

                    result.shouldBeRight()
                    result.getOrNull() shouldBe canonicalAlias

                    coVerify(exactly = 0) { repository.update(any()) }
                }

                it("should fail when alias not found") {
                    coEvery { repository.findByAliasName(aliasName) } returns null.right()

                    val result = service.setCanonicalAlias(aliasName)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe ScopeAliasError.AliasNotFound(aliasName.value)
                }
            }

            describe("findAliasesByScopeId") {
                it("should return all aliases for a scope") {
                    val canonical = ScopeAlias.createCanonical(scopeId, aliasName)
                    val custom1 = ScopeAlias.createCustom(
                        scopeId,
                        AliasName.create("custom-1").getOrNull()!!,
                    )
                    val custom2 = ScopeAlias.createCustom(
                        scopeId,
                        AliasName.create("custom-2").getOrNull()!!,
                    )
                    val aliases = listOf(canonical, custom1, custom2)

                    coEvery { repository.findByScopeId(scopeId) } returns aliases.right()

                    val result = service.findAliasesByScopeId(scopeId)

                    result.shouldBeRight()
                    result.getOrNull() shouldBe aliases
                }

                it("should return empty list when no aliases found") {
                    coEvery { repository.findByScopeId(scopeId) } returns emptyList<ScopeAlias>().right()

                    val result = service.findAliasesByScopeId(scopeId)

                    result.shouldBeRight()
                    result.getOrNull() shouldBe emptyList()
                }
            }

            describe("findAliasesByPrefix") {
                it("should return aliases matching prefix") {
                    val prefix = AliasName.create("test").getOrNull()!!
                    val matching1 = ScopeAlias.createCanonical(
                        scopeId,
                        AliasName.create("test-alias-1").getOrNull()!!,
                    )
                    val matching2 = ScopeAlias.createCustom(
                        scopeId,
                        AliasName.create("testing-alias").getOrNull()!!,
                    )
                    val matches = listOf(matching1, matching2)

                    coEvery { repository.findByAliasNamePrefix(prefix, 10) } returns matches.right()

                    val result = service.findAliasesByPrefix(prefix, 10)

                    result.shouldBeRight()
                    result.getOrNull() shouldBe matches
                }

                it("should respect limit parameter") {
                    val prefix = AliasName.create("test").getOrNull()!!
                    val matches = (1..5).map { i ->
                        ScopeAlias.createCustom(
                            scopeId,
                            AliasName.create("test-alias-$i").getOrNull()!!,
                        )
                    }

                    coEvery { repository.findByAliasNamePrefix(prefix, 3) } returns matches.take(3).right()

                    val result = service.findAliasesByPrefix(prefix, 3)

                    result.shouldBeRight()
                    result.getOrNull()?.size shouldBe 3
                }
            }

            describe("error propagation") {
                it("should propagate repository errors") {
                    val repositoryError = ScopeAliasError.AliasNotFound("test")

                    coEvery { repository.findByAliasName(aliasName) } returns repositoryError.left()

                    val result = service.removeAlias(aliasName)

                    result.shouldBeLeft()
                    result.leftOrNull() shouldBe repositoryError
                }
            }
        }
    })
