-- Events table for Event Store
CREATE TABLE IF NOT EXISTS events (
    sequence_number INTEGER PRIMARY KEY AUTOINCREMENT,
    event_id TEXT NOT NULL UNIQUE,
    aggregate_id TEXT NOT NULL,
    aggregate_version INTEGER NOT NULL,
    event_type TEXT NOT NULL,
    event_data TEXT NOT NULL,
    occurred_at INTEGER NOT NULL,
    stored_at INTEGER NOT NULL
);

-- Indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_events_aggregate_id_version ON events(aggregate_id, aggregate_version);
CREATE INDEX IF NOT EXISTS idx_events_stored_at ON events(stored_at);
CREATE INDEX IF NOT EXISTS idx_events_occurred_at ON events(occurred_at);
-- sequence_number is PRIMARY KEY, already indexed
-- Composite index for event_type + sequence_number queries (covers findEventsByType queries)
CREATE INDEX IF NOT EXISTS idx_events_event_type_sequence_number ON events(event_type, sequence_number);
-- Composite index for event_type + occurred_at queries
CREATE INDEX IF NOT EXISTS idx_events_event_type_occurred_at ON events(event_type, occurred_at);

-- Insert event (sequence_number is auto-generated)
insertEvent:
INSERT INTO events (
    event_id,
    aggregate_id,
    aggregate_version,
    event_type,
    event_data,
    occurred_at,
    stored_at
) VALUES (?, ?, ?, ?, ?, ?, ?);

-- Get event by event_id
getEventByEventId:
SELECT * FROM events WHERE event_id = ?;

-- Find events since timestamp
findEventsSince:
SELECT *
FROM events
WHERE stored_at >= ?
ORDER BY sequence_number ASC
LIMIT ?;

-- Find events by aggregate ID
findEventsByAggregateId:
SELECT *
FROM events
WHERE aggregate_id = ?
ORDER BY aggregate_version ASC
LIMIT ?;

-- Find events by aggregate ID since timestamp
findEventsByAggregateIdSince:
SELECT *
FROM events
WHERE aggregate_id = ?
AND stored_at >= ?
ORDER BY aggregate_version ASC
LIMIT ?;

-- Find events by event type
findEventsByType:
SELECT *
FROM events
WHERE event_type = ?
ORDER BY sequence_number ASC
LIMIT ?;

-- Find events by event type since timestamp (by occurredAt)
findEventsByTypeSince:
SELECT *
FROM events
WHERE event_type = ?
AND occurred_at >= ?
ORDER BY sequence_number ASC
LIMIT ?;

-- Find events by time range (by occurredAt)
findEventsByTimeRange:
SELECT *
FROM events
WHERE occurred_at >= ?
AND occurred_at < ?
ORDER BY sequence_number ASC
LIMIT ?;

-- Find events by event type with pagination
findEventsByTypeWithPagination:
SELECT *
FROM events
WHERE event_type = ?
ORDER BY sequence_number ASC
LIMIT ?
OFFSET ?;

-- Find events by time range with pagination (by occurredAt)
findEventsByTimeRangeWithPagination:
SELECT *
FROM events
WHERE occurred_at >= ?
AND occurred_at < ?
ORDER BY sequence_number ASC
LIMIT ?
OFFSET ?;

-- ===== OPTIMIZATION QUERIES FOR LONG-LIVED AGGREGATES =====

-- Get latest version for an aggregate (optimized for long-lived aggregates)
getLatestAggregateVersion:
SELECT MAX(aggregate_version)
FROM events
WHERE aggregate_id = ?;

-- Get events from specific version onwards (for incremental loading)
findEventsByAggregateIdFromVersion:
SELECT *
FROM events
WHERE aggregate_id = ?
AND aggregate_version >= ?
ORDER BY aggregate_version ASC
LIMIT ?;

-- Get events in version range (for partial replay)
findEventsByAggregateIdVersionRange:
SELECT *
FROM events
WHERE aggregate_id = ?
AND aggregate_version >= ?
AND aggregate_version <= ?
ORDER BY aggregate_version ASC
LIMIT ?;

-- Get latest N events for an aggregate (for recent activity)
findLatestEventsByAggregateId:
SELECT *
FROM events
WHERE aggregate_id = ?
ORDER BY aggregate_version DESC
LIMIT ?;

-- Count total events for an aggregate (for performance monitoring)
countEventsByAggregateId:
SELECT COUNT(*)
FROM events
WHERE aggregate_id = ?;

-- Get aggregate event statistics (for snapshot decision making)
getAggregateEventStats:
SELECT 
    COUNT(*),
    MIN(aggregate_version),
    MAX(aggregate_version),
    MIN(occurred_at),
    MAX(occurred_at)
FROM events
WHERE aggregate_id = ?;
