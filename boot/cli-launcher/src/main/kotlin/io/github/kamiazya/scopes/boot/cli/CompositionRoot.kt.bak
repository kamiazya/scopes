package io.github.kamiazya.scopes.boot.cli

import io.github.kamiazya.scopes.application.error.ErrorMessageFormatter
import io.github.kamiazya.scopes.application.logging.Logger
import io.github.kamiazya.scopes.application.logging.LogLevel
import io.github.kamiazya.scopes.application.port.TransactionManager
import io.github.kamiazya.scopes.application.service.CrossAggregateValidationService
import io.github.kamiazya.scopes.application.usecase.handler.CreateScopeHandler
import io.github.kamiazya.scopes.domain.repository.ScopeAliasRepository
import io.github.kamiazya.scopes.domain.repository.ScopeRepository
import io.github.kamiazya.scopes.domain.service.AliasGenerationService
import io.github.kamiazya.scopes.domain.service.ScopeAliasManagementService
import io.github.kamiazya.scopes.domain.service.ScopeHierarchyService
import io.github.kamiazya.scopes.domain.service.WordProvider
import io.github.kamiazya.scopes.infrastructure.alias.generation.DefaultAliasGenerationService
import io.github.kamiazya.scopes.infrastructure.alias.generation.providers.DefaultWordProvider
import io.github.kamiazya.scopes.infrastructure.alias.generation.strategies.HaikunatorStrategy
import io.github.kamiazya.scopes.application.logging.logger
import io.github.kamiazya.scopes.application.logging.ApplicationType
import io.github.kamiazya.scopes.infrastructure.logging.runtime.NativeRuntimeInfoProvider
import io.github.kamiazya.scopes.infrastructure.logging.CoroutineLoggingContextScope
import io.github.kamiazya.scopes.application.logging.LoggingContextScope
import io.github.kamiazya.scopes.infrastructure.logging.LoggerComponentInitializer
import io.github.kamiazya.scopes.infrastructure.repository.InMemoryScopeAliasRepository
import io.github.kamiazya.scopes.infrastructure.repository.InMemoryScopeRepository
import io.github.kamiazya.scopes.infrastructure.transaction.NoopTransactionManager
import io.github.kamiazya.scopes.apps.cli.commands.CreateScopeCommand
import io.github.kamiazya.scopes.apps.cli.error.CliErrorMessageFormatter
import org.koin.core.context.GlobalContext
import org.koin.core.context.startKoin
import org.koin.core.qualifier.named
import org.koin.dsl.module

/**
 * Composition Root for the CLI boot layer.
 *
 * This is the single place where all dependencies are wired together.
 * It follows the Composition Root pattern from Clean Architecture,
 * where infrastructure dependencies are resolved at the application's entry point.
 *
 * The boot layer is responsible for:
 * - Initializing the dependency injection container
 * - Wiring together all layers (infrastructure, domain, application, apps)
 * - Configuring logging and other cross-cutting concerns
 * - Providing the thin entry point for the application
 */
object CompositionRoot {

    /**
     * Initialize the dependency injection container with all required modules.
     * This is idempotent and safe to call multiple times - it only initializes
     * Koin if it's not already running.
     */
    fun initialize() {
        if (GlobalContext.getOrNull() == null) {
            // Initialize logger components
            LoggerComponentInitializer.initialize()

            startKoin {
                modules(
                    infrastructureModule,
                    domainModule,
                    applicationModule,
                    appsModule
                )
            }
        }
    }

    /**
     * Infrastructure layer dependencies.
     * Contains concrete implementations of ports/adapters.
     */
    private val infrastructureModule = module {
        single<ScopeRepository> { InMemoryScopeRepository() }
        single<ScopeAliasRepository> { InMemoryScopeAliasRepository() }
        single<TransactionManager> { NoopTransactionManager() }

        // Alias generation infrastructure
        single { HaikunatorStrategy() }
        single<WordProvider> { DefaultWordProvider() }
        single<AliasGenerationService> {
            DefaultAliasGenerationService(get<HaikunatorStrategy>(), get())
        }

        // Logging context scope for coroutine-based context propagation
        single<LoggingContextScope> { CoroutineLoggingContextScope() }

        // Logger configuration - available to all layers
        single<Logger>(named("app")) {
            logger {
                name = "ScopesApp"

                application {
                    name = "scopes-cli"
                    version = getApplicationVersion()
                    type = ApplicationType.CLI
                }

                runtime(NativeRuntimeInfoProvider.get())

                console {
                    plainText()
                }

                context {
                    put("environment", System.getenv("ENV") ?: "development")
                }

                contextScope(get())
            }
        }

        // CLI-specific logger
        single<Logger>(named("cli")) {
            logger {
                name = "ScopesCLI"

                application {
                    name = "scopes-cli"
                    version = getApplicationVersion()
                    type = ApplicationType.CLI
                }

                runtime(NativeRuntimeInfoProvider.get())

                console {
                    plainText()
                    level = LogLevel.INFO // Less verbose for CLI output
                }

                contextScope(get())
            }
        }
    }

    /**
     * Domain layer dependencies.
     * Domain services that encapsulate business logic.
     */
    private val domainModule = module {
        single { ScopeHierarchyService() }
        single { ScopeAliasManagementService(get(), get()) }
    }

    /**
     * Application layer dependencies.
     * Contains use case handlers, services, and application-specific implementations.
     */
    private val applicationModule = module {
        single { CrossAggregateValidationService(get()) }
        single {
            CreateScopeHandler(
                scopeRepository = get(),
                transactionManager = get(),
                hierarchyService = get(),
                crossAggregateValidationService = get(),
                aliasManagementService = get(),
                logger = get(named("app"))
            )
        }
    }

    /**
     * Apps layer dependencies.
     * Contains presentation logic for CLI commands.
     */
    private val appsModule = module {
        single<ErrorMessageFormatter> { CliErrorMessageFormatter }
        single { CreateScopeCommand(get(), get(), get()) }
    }

    /**
     * Gets the application version from system properties or defaults to "dev".
     */
    private fun getApplicationVersion(): String {
        return System.getProperty("app.version") ?: "dev"
    }
}