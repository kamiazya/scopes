name: Release

on:
  push:
    tags: ['v*.*.*', 'v*.*.*-*']
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0, v2.0.0-alpha)'
        required: true
        type: string

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read
  id-token: write
  attestations: write

env:
  QUARKUS_BUILDER_IMAGE_LINUX_ARM64: "ghcr.io/graalvm/graalvm-ce:ol8-java11-22.3.3@sha256:1622fe4beeb753c07e9196d9ab68755f42d661872a1e9b548b549d6e60194477"

jobs:
  build-release:
    name: Build Release Artifacts
    runs-on: ${{ matrix.os }}
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}

    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            arch: x64
          - os: ubuntu-latest
            platform: linux
            arch: arm64
          - os: macos-13
            platform: darwin
            arch: x64
          - os: macos-14
            platform: darwin
            arch: arm64
          - os: windows-latest
            platform: win32
            arch: x64
          - os: windows-latest
            platform: win32
            arch: arm64
            experimental: true

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup QEMU for ARM64 cross-compilation
        if: matrix.platform == 'linux' && matrix.arch == 'arm64'
        uses: docker/setup-qemu-action@49b3bc8e6bdd4a60e6116a5414239cba5943d3cf # v3.2.0
        with:
          platforms: linux/arm64

      - name: Setup Windows Build Environment
        if: matrix.platform == 'win32'
        uses: ./.github/actions/setup-windows-build

      - name: Set up GraalVM
        uses: graalvm/setup-graalvm@7f488cf82a3629ee755e4e97342c01d6bed318fa # v1.3.5
        with:
          java-version: '21'
          distribution: 'graalvm'
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@017a9effdb900e5b5b2fddfb590a105619dca3c3 # v4.4.2
        with:
          validate-wrappers: true

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix for SemVer compatibility (v1.0.0 -> 1.0.0)
          CLEAN_VERSION=${VERSION#v}
          echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $CLEAN_VERSION (from tag: $VERSION)"

      - name: Build native binary (Windows)
        if: matrix.platform == 'win32'
        run: |
          Set-Location "C:\build-workspace\scopes"
          $VERSION_ARG = "-Pversion=${{ steps.version.outputs.version }}"

          # Add architecture-specific flags for ARM64
          $ARCH_FLAGS = ""
          if ("${{ matrix.arch }}" -eq "arm64") {
            $ARCH_FLAGS = "-Dquarkus.native.additional-build-args=--target=aarch64-pc-windows"
          }

          # Disable configuration cache for native build due to GraalVM plugin incompatibility
          # See: https://github.com/kamiazya/scopes/issues/36
          echo "Executing: .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:nativeCompile $VERSION_ARG $ARCH_FLAGS"
          & .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:nativeCompile $VERSION_ARG $ARCH_FLAGS
        shell: powershell
        env:
          GRADLE_USER_HOME: C:\gradle-cache

      - name: Build native binary (Unix)
        if: matrix.platform != 'win32'
        run: |
          # Add architecture-specific flags for cross-compilation
          ARCH_FLAGS=""
          if [ "${{ matrix.platform }}" = "linux" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            ARCH_FLAGS="-Dquarkus.native.container-build=true -Dquarkus.native.builder-image=${QUARKUS_BUILDER_IMAGE_LINUX_ARM64:-ghcr.io/graalvm/graalvm-ce:ol8-java11-22.3.3@sha256:1622fe4beeb753c07e9196d9ab68755f42d661872a1e9b548b549d6e60194477}"
          fi

          # Disable configuration cache for native build due to GraalVM plugin incompatibility
          # See: https://github.com/kamiazya/scopes/issues/36
          ./gradlew --no-daemon --no-configuration-cache --scan :apps-scopes:nativeCompile -Pversion="${{ steps.version.outputs.version }}" $ARCH_FLAGS

      - name: Prepare binary for upload
        shell: bash
        run: |
          if [ "${{ matrix.platform }}" = "win32" ]; then
            BINARY_NAME="scopes-${{ steps.version.outputs.tag_version }}-${{ matrix.platform }}-${{ matrix.arch }}.exe"
            cp /c/build-workspace/scopes/apps/scopes/build/native/nativeCompile/scopes.exe "$BINARY_NAME"
          else
            BINARY_NAME="scopes-${{ steps.version.outputs.tag_version }}-${{ matrix.platform }}-${{ matrix.arch }}"
            cp apps/scopes/build/native/nativeCompile/scopes "$BINARY_NAME"
          fi
          echo "binary_name=$BINARY_NAME" >> $GITHUB_OUTPUT
        id: binary

      - name: Generate SBOM (CycloneDX) (Windows)
        if: matrix.platform == 'win32'
        run: |
          Set-Location "C:\build-workspace\scopes"
          $VERSION_ARG = "-Pversion=${{ steps.version.outputs.version }}"
          # Disable configuration cache for SBOM generation due to GraalVM plugin incompatibility
          echo "Executing: .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom $VERSION_ARG"
          & .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom $VERSION_ARG
        shell: powershell
        env:
          GRADLE_USER_HOME: C:\gradle-cache

      - name: Generate SBOM (CycloneDx) (Unix)
        if: matrix.platform != 'win32'
        run: |
          # Disable configuration cache for SBOM generation due to GraalVM plugin incompatibility
          ./gradlew --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom


      - name: Generate hash for SLSA provenance
        shell: bash
        id: hash
        run: |
          set -euo pipefail
          echo "Generating hash for: ${{ steps.binary.outputs.binary_name }}"

          # Generate SHA256 hash for binary
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # On Windows, certutil outputs in a specific format, we need to extract just the hash
            HASH_OUTPUT=$(certutil -hashfile "${{ steps.binary.outputs.binary_name }}" SHA256)
            # Extract the second line which contains the hash
            HASH=$(echo "$HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            HASH=$(shasum -a 256 "${{ steps.binary.outputs.binary_name }}" | awk '{print $1}')
          else
            HASH=$(sha256sum "${{ steps.binary.outputs.binary_name }}" | awk '{print $1}')
          fi

          echo "Hash: $HASH"
          echo "${{ steps.binary.outputs.binary_name }}:$HASH" >> hashes.txt

          # Create individual hash file with proper format
          echo "${{ steps.binary.outputs.binary_name }}:$HASH" > binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Verify the hash file was created correctly
          echo "Generated hash file content:"
          cat binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Generate hashes for SBOM files
          if [ "${{ matrix.platform }}" = "win32" ]; then
            SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
            SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
          else
            SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
            SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
          fi

          if [ -f "$SBOM_JSON_PATH" ]; then
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              SBOM_JSON_HASH_OUTPUT=$(certutil -hashfile "$SBOM_JSON_PATH" SHA256)
              SBOM_JSON_HASH=$(echo "$SBOM_JSON_HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              SBOM_JSON_HASH=$(shasum -a 256 "$SBOM_JSON_PATH" | awk '{print $1}')
            else
              SBOM_JSON_HASH=$(sha256sum "$SBOM_JSON_PATH" | awk '{print $1}')
            fi
            echo "sbom-${{ matrix.platform }}-${{ matrix.arch }}.json:$SBOM_JSON_HASH" >> hashes.txt
          fi

          if [ -f "$SBOM_XML_PATH" ]; then
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              SBOM_XML_HASH_OUTPUT=$(certutil -hashfile "$SBOM_XML_PATH" SHA256)
              SBOM_XML_HASH=$(echo "$SBOM_XML_HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              SBOM_XML_HASH=$(shasum -a 256 "$SBOM_XML_PATH" | awk '{print $1}')
            else
              SBOM_XML_HASH=$(sha256sum "$SBOM_XML_PATH" | awk '{print $1}')
            fi
            echo "sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml:$SBOM_XML_HASH" >> hashes.txt
          fi

          # Create base64 encoded hash for SLSA (encoded_hash artifact_name format)
          printf "%s %s\n" "$(echo -n "$HASH" | base64)" "${{ steps.binary.outputs.binary_name }}" > hashes-b64-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Set output variable for downstream steps
          ALL_HASHES=$(cat hashes.txt | tr '\n' ' ' | sed 's/ $//')
          echo "hashes=$ALL_HASHES" >> $GITHUB_OUTPUT

      - name: Upload binary artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: binary-${{ matrix.platform }}-${{ matrix.arch }}
          path: ${{ steps.binary.outputs.binary_name }}

      - name: Prepare SBOM files for upload
        shell: bash
        run: |
          # Copy SBOM files with platform-specific names
          if [ "${{ matrix.platform }}" = "win32" ]; then
            SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
            SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
          else
            SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
            SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
          fi

          if [ -f "$SBOM_JSON_PATH" ]; then
            cp "$SBOM_JSON_PATH" "sbom-${{ matrix.platform }}-${{ matrix.arch }}.json"
          fi

          if [ -f "$SBOM_XML_PATH" ]; then
            cp "$SBOM_XML_PATH" "sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml"
          fi

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: sbom-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            sbom-${{ matrix.platform }}-${{ matrix.arch }}.json
            sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml


      - name: Upload hash artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: hashes-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            hashes.txt
            hashes-b64-${{ matrix.platform }}-${{ matrix.arch }}.txt
            binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

  collect-hashes:
    name: Collect Hashes for SLSA
    runs-on: ubuntu-latest
    needs: build-release
    outputs:
      hashes: ${{ steps.collect.outputs.hashes }}

    steps:
      - name: Download all hash artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: hashes-*
          path: all-hashes

      - name: Collect all hashes
        id: collect
        run: |
          set -euo pipefail
          echo "Collecting hashes from all platforms..."

          # List all downloaded files for debugging
          echo "Downloaded artifacts structure:"
          find all-hashes -name "*.txt" -type f | sort

          # Combine all hash files from all platforms, decoding individual hashes
          echo "Combining hashes from all platforms..."

          # Initialize the combined hashes file
          > combined-hashes.txt

          # Process all hashes-b64-*.txt files dynamically
          first=true
          for hash_file in all-hashes/*/hashes-b64-*.txt; do
            if [ -f "$hash_file" ]; then
              echo "Processing: $hash_file"

              # Add newline separator between files (except for first file)
              if [ "$first" = false ]; then
                echo "" >> combined-hashes.txt
              fi
              first=false

              # Decode each hash and append to combined file
              while IFS=' ' read -r encoded_hash filename; do
                decoded_hash=$(echo -n "$encoded_hash" | base64 -d)
                echo "$decoded_hash $filename" >> combined-hashes.txt
              done < "$hash_file"
            fi
          done

          # Create base64 encoded string for SLSA (sha256sum format)
          HASHES_B64=$(cat combined-hashes.txt | base64 -w0)
          echo "hashes=$HASHES_B64" >> $GITHUB_OUTPUT

          echo "Collected hashes (pre-base64):"
          cat combined-hashes.txt

          echo "Collected hashes (readable):"
          cat all-hashes/*/hashes.txt

          echo "Base64 encoded for SLSA:"
          echo "$HASHES_B64"

  provenance:
    name: Generate SLSA Provenance
    needs: [build-release, collect-hashes]
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@f7dd8c54c2067bafc12ca7a55595d5ee9b75204a # v2.1.0
    with:
      base64-subjects: "${{ needs.collect-hashes.outputs.hashes }}"
      upload-assets: true

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-release, provenance]
    if: always() && needs.build-release.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix for SemVer compatibility (v1.0.0 -> 1.0.0)
          CLEAN_VERSION=${VERSION#v}
          echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: artifacts

      - name: Download all SBOM artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          pattern: sbom-*
          path: sbom-artifacts
          merge-multiple: true


      - name: Download SLSA provenance
        if: needs.provenance.result == 'success'
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          name: "${{ needs.provenance.outputs.provenance-name }}"
          path: provenance

      - name: Display downloaded artifacts
        run: find artifacts -type f -name "*" | head -20

      - name: Generate enhanced release notes
        id: release_notes
        run: |
          # Generate release notes with verification instructions
          cat > release_notes.md << 'EOF'
          ## ðŸ” Verification Instructions
          > **Security Notice**: This release is signed and includes SLSA provenance for supply chain security.

          ### Quick Verification
          ```bash
          # Download and verify in one command
          curl -sSL https://raw.githubusercontent.com/kamiazya/scopes/main/install/install.sh | bash
          ```

          ### Manual Verification
          For detailed verification instructions, see our [Security Verification Guide](./docs/guides/security-verification.md).

          ## ðŸ“¦ Artifacts
          - Binary downloads include SHA-256 checksums
          - SLSA Level 3 provenance attached
          - SBOM files available in CycloneDX format

          ## ðŸ“š Documentation
          - [Installation Guide](./install/README.md)
          - [Security Verification](./docs/guides/security-verification.md)
          - [SBOM Verification](./docs/guides/sbom-verification.md)
          EOF

          # Store the custom content
          {
            echo "custom_content<<EOF"
            cat release_notes.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create or update GitHub Release with auto-generated notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create or update release with GitHub's auto-generated notes
          if ! gh release view "${{ steps.version.outputs.tag_version }}" > /dev/null 2>&1; then
            # Create new release with auto-generated notes
            gh release create "${{ steps.version.outputs.tag_version }}" \
              --title "Release ${{ steps.version.outputs.tag_version }}" \
              --generate-notes \
              --prerelease=${{ contains(steps.version.outputs.tag_version, '-') }}
          else
            # Release exists, delete and recreate to get auto-generated notes
            echo "Release already exists, recreating with auto-generated notes"
            gh release delete "${{ steps.version.outputs.tag_version }}" --yes
            gh release create "${{ steps.version.outputs.tag_version }}" \
              --title "Release ${{ steps.version.outputs.tag_version }}" \
              --generate-notes \
              --prerelease=${{ contains(steps.version.outputs.tag_version, '-') }}
          fi

      - name: Upload release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Upload all binary artifacts
          find artifacts -name "scopes-*" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" {} \;

          # Upload hash files
          find artifacts -name "binary-hash-*.txt" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" {} \;

          # Upload SBOM files
          find sbom-artifacts -name "sbom-*.json" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" {} \;
          find sbom-artifacts -name "sbom-*.xml" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" {} \;

          # Upload SLSA provenance if available
          if [ -d "provenance" ] && [ -n "$(find provenance -name "*.intoto.jsonl" -type f)" ]; then
            find provenance -name "*.intoto.jsonl" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" {} \;
          fi

      - name: Enhance release notes with custom content
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the auto-generated release notes
          AUTO_NOTES=$(gh release view "${{ steps.version.outputs.tag_version }}" --json body --jq '.body')

          # Create the combined release notes
          cat > combined_notes.md << 'EOF'
          ${{ steps.release_notes.outputs.custom_content }}

          ## Installation

          Download the appropriate binary for your platform from the assets below.

          ### Linux/macOS
          ```bash
          chmod +x scopes-*
          sudo mv scopes-* /usr/local/bin/scopes
          ```

          ### Windows
          Extract `scopes-*.exe` to a directory in your PATH.

          ## Security & Verification

          This release includes SLSA Level 3 provenance and Software Bill of Materials (SBOM) for comprehensive supply chain security.

          ### SLSA Provenance Verification
          ```bash
          # Install slsa-verifier
          go install github.com/slsa-framework/slsa-verifier/v2/cli/slsa-verifier@latest

          # Verify the binary (example for Linux)
          slsa-verifier verify-artifact scopes-${{ steps.version.outputs.tag_version }}-linux-x64 \
            --provenance-path multiple.intoto.jsonl \
            --source-uri github.com/${{ github.repository }}
          ```

          ### SBOM (Software Bill of Materials)

          Each platform includes SBOM files in both industry-standard formats:
          - **CycloneDX** (JSON/XML): Security-focused with vulnerability tracking capabilities
          - Download: `sbom-{platform}-{arch}.json` or `sbom-{platform}-{arch}.xml`

          #### SBOM Usage Examples
          ```bash
          # Analyze dependencies with CycloneDX tools
          cyclonedx-cli analyze sbom-linux-x64.json

          # Import into OWASP Dependency-Track
          curl -X POST "http://dtrack-server/api/v1/bom" \
            -H "X-API-Key: your-api-key" \
            -H "Content-Type: application/json" \
            -d @sbom-linux-x64.json
          ```

          ### Manual Verification
          See the checksums in `binary-hash-*.txt` files for manual verification of binaries.
          EOF

          # Add the auto-generated notes after our custom content
          echo "" >> combined_notes.md
          echo "$AUTO_NOTES" >> combined_notes.md

          # Update the release with combined content
          gh release edit "${{ steps.version.outputs.tag_version }}" --notes-file combined_notes.md
