name: Release

on:
  push:
    tags: ['v*.*.*', 'v*.*.*-*']
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0, v2.0.0-alpha)'
        required: true
        type: string
  workflow_call:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.0.0, v2.0.0-alpha)'
        required: true
        type: string

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read
  id-token: write
  attestations: write

env:
  QUARKUS_BUILDER_IMAGE_LINUX_ARM64: "ghcr.io/graalvm/graalvm-ce:ol8-java11-22.3.3@sha256:1622fe4beeb753c07e9196d9ab68755f42d661872a1e9b548b549d6e60194477"

jobs:
  build-release:
    name: Build Release Artifacts
    runs-on: ${{ matrix.os }}
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}

    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            arch: x64
          - os: ubuntu-latest
            platform: linux
            arch: arm64
          - os: macos-13
            platform: darwin
            arch: x64
          - os: macos-14
            platform: darwin
            arch: arm64
          - os: windows-latest
            platform: win32
            arch: x64
          - os: windows-latest
            platform: win32
            arch: arm64
            experimental: true

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Setup QEMU for ARM64 cross-compilation
        if: matrix.platform == 'linux' && matrix.arch == 'arm64'
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3.6.0
        with:
          platforms: linux/arm64

      - name: Setup Windows Build Environment
        if: matrix.platform == 'win32'
        uses: ./.github/actions/setup-windows-build

      - name: Set up GraalVM
        uses: graalvm/setup-graalvm@aba6a077d71fbfc02138d7470c4ad6e7f85bd2a9 # v1.3.7
        with:
          java-version: '21'
          distribution: 'graalvm'
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@ed408507eac070d1f99cc633dbcf757c94c7933a # v4.4.3
        with:
          validate-wrappers: true

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          elif [ "${{ github.event_name }}" = "workflow_call" ]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix for SemVer compatibility (v1.0.0 -> 1.0.0)
          CLEAN_VERSION=${VERSION#v}
          echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $CLEAN_VERSION (from tag: $VERSION)"

      - name: Build native binary (Windows)
        if: matrix.platform == 'win32'
        run: |
          Set-Location "C:\build-workspace\scopes"
          $VERSION_ARG = "-Pversion=${{ steps.version.outputs.version }}"

          # Add architecture-specific flags for ARM64
          $ARCH_FLAGS = ""
          if ("${{ matrix.arch }}" -eq "arm64") {
            $ARCH_FLAGS = "-Dquarkus.native.additional-build-args=--target=aarch64-pc-windows"
          }

          # Disable configuration cache for native build due to GraalVM plugin incompatibility
          # See: https://github.com/kamiazya/scopes/issues/36
          # Run clean build first for reproducible builds
          echo "Executing: .\gradlew.bat --no-daemon --no-configuration-cache --scan clean :apps-scopes:nativeCompile $VERSION_ARG $ARCH_FLAGS"
          & .\gradlew.bat --no-daemon --no-configuration-cache --scan clean :apps-scopes:nativeCompile $VERSION_ARG $ARCH_FLAGS
        shell: powershell
        env:
          GRADLE_USER_HOME: C:\gradle-cache

      - name: Build native binary (Unix)
        if: matrix.platform != 'win32'
        run: |
          # Add architecture-specific flags for cross-compilation
          ARCH_FLAGS=""
          if [ "${{ matrix.platform }}" = "linux" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            ARCH_FLAGS="-Dquarkus.native.container-build=true -Dquarkus.native.builder-image=${QUARKUS_BUILDER_IMAGE_LINUX_ARM64:-ghcr.io/graalvm/graalvm-ce:ol8-java11-22.3.3@sha256:1622fe4beeb753c07e9196d9ab68755f42d661872a1e9b548b549d6e60194477}"
          fi

          # Disable configuration cache for native build due to GraalVM plugin incompatibility
          # See: https://github.com/kamiazya/scopes/issues/36
          # Run clean build first for reproducible builds
          ./gradlew --no-daemon --no-configuration-cache --scan clean :apps-scopes:nativeCompile -Pversion="${{ steps.version.outputs.version }}" $ARCH_FLAGS

      - name: Prepare binary for upload
        shell: bash
        run: |
          if [ "${{ matrix.platform }}" = "win32" ]; then
            BINARY_NAME="scopes-${{ steps.version.outputs.version }}-${{ matrix.platform }}-${{ matrix.arch }}.exe"
            cp /c/build-workspace/scopes/apps/scopes/build/native/nativeCompile/scopes.exe "$BINARY_NAME"
          else
            BINARY_NAME="scopes-${{ steps.version.outputs.version }}-${{ matrix.platform }}-${{ matrix.arch }}"
            cp apps/scopes/build/native/nativeCompile/scopes "$BINARY_NAME"
          fi
          echo "binary_name=$BINARY_NAME" >> $GITHUB_OUTPUT
        id: binary

      - name: Generate SBOM (CycloneDX) (Windows)
        if: matrix.platform == 'win32'
        run: |
          Set-Location "C:\build-workspace\scopes"
          $VERSION_ARG = "-Pversion=${{ steps.version.outputs.version }}"
          # Disable configuration cache for SBOM generation due to GraalVM plugin incompatibility
          echo "Executing: .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom $VERSION_ARG"
          & .\gradlew.bat --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom $VERSION_ARG
        shell: powershell
        env:
          GRADLE_USER_HOME: C:\gradle-cache

      - name: Generate SBOM (CycloneDx) (Unix)
        if: matrix.platform != 'win32'
        run: |
          # Disable configuration cache for SBOM generation due to GraalVM plugin incompatibility
          # Pass version property to ensure SBOM metadata matches the binaries
          ./gradlew --no-daemon --no-configuration-cache --scan :apps-scopes:cycloneDxBom -Pversion="${{ steps.version.outputs.version }}"


      - name: Generate hash for SLSA provenance
        shell: bash
        id: hash
        run: |
          set -euo pipefail
          echo "Generating hash for: ${{ steps.binary.outputs.binary_name }}"

          # Generate SHA256 hash for binary
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # On Windows, certutil outputs in a specific format, we need to extract just the hash
            HASH_OUTPUT=$(certutil -hashfile "${{ steps.binary.outputs.binary_name }}" SHA256)
            # Extract the second line which contains the hash
            HASH=$(echo "$HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            HASH=$(shasum -a 256 "${{ steps.binary.outputs.binary_name }}" | awk '{print $1}')
          else
            HASH=$(sha256sum "${{ steps.binary.outputs.binary_name }}" | awk '{print $1}')
          fi

          echo "Hash: $HASH"
          echo "${{ steps.binary.outputs.binary_name }}:$HASH" >> hashes.txt

          # Create individual hash file with proper format
          echo "${{ steps.binary.outputs.binary_name }}:$HASH" > binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Verify the hash file was created correctly
          echo "Generated hash file content:"
          cat binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Generate hashes for SBOM files with fallback detection
          if [ "${{ matrix.platform }}" = "win32" ]; then
            # Check for SBOM files in the default location first
            if [ -f "/c/build-workspace/scopes/apps/scopes/build/reports/bom.json" ]; then
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
            # Fall back to cyclonedx subdirectory if not found
            elif [ -f "/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.json" ]; then
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.xml"
            else
              echo "Warning: SBOM files not found in expected locations"
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
            fi
          else
            # Check for SBOM files in the default location first
            if [ -f "apps/scopes/build/reports/bom.json" ]; then
              SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
            # Fall back to cyclonedx subdirectory if not found
            elif [ -f "apps/scopes/build/reports/cyclonedx/bom.json" ]; then
              SBOM_JSON_PATH="apps/scopes/build/reports/cyclonedx/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/cyclonedx/bom.xml"
            else
              echo "Warning: SBOM files not found in expected locations"
              SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
            fi
          fi

          if [ -f "$SBOM_JSON_PATH" ]; then
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              SBOM_JSON_HASH_OUTPUT=$(certutil -hashfile "$SBOM_JSON_PATH" SHA256)
              SBOM_JSON_HASH=$(echo "$SBOM_JSON_HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              SBOM_JSON_HASH=$(shasum -a 256 "$SBOM_JSON_PATH" | awk '{print $1}')
            else
              SBOM_JSON_HASH=$(sha256sum "$SBOM_JSON_PATH" | awk '{print $1}')
            fi
            echo "sbom-${{ matrix.platform }}-${{ matrix.arch }}.json:$SBOM_JSON_HASH" >> hashes.txt
          fi

          if [ -f "$SBOM_XML_PATH" ]; then
            if [[ "${{ runner.os }}" == "Windows" ]]; then
              SBOM_XML_HASH_OUTPUT=$(certutil -hashfile "$SBOM_XML_PATH" SHA256)
              SBOM_XML_HASH=$(echo "$SBOM_XML_HASH_OUTPUT" | sed -n '2p' | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
            elif [[ "${{ runner.os }}" == "macOS" ]]; then
              SBOM_XML_HASH=$(shasum -a 256 "$SBOM_XML_PATH" | awk '{print $1}')
            else
              SBOM_XML_HASH=$(sha256sum "$SBOM_XML_PATH" | awk '{print $1}')
            fi
            echo "sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml:$SBOM_XML_HASH" >> hashes.txt
          fi

          # Create base64 encoded hash for SLSA (encoded_hash artifact_name format)
          printf "%s %s\n" "$(echo -n "$HASH" | base64)" "${{ steps.binary.outputs.binary_name }}" > hashes-b64-${{ matrix.platform }}-${{ matrix.arch }}.txt

          # Set output variable for downstream steps
          ALL_HASHES=$(cat hashes.txt | tr '\n' ' ' | sed 's/ $//')
          echo "hashes=$ALL_HASHES" >> $GITHUB_OUTPUT

      - name: Upload binary artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: binary-${{ matrix.platform }}-${{ matrix.arch }}
          path: ${{ steps.binary.outputs.binary_name }}

      - name: Prepare SBOM files for upload
        shell: bash
        run: |
          # Copy SBOM files with platform-specific names using same fallback detection logic
          if [ "${{ matrix.platform }}" = "win32" ]; then
            # Check for SBOM files in the default location first
            if [ -f "/c/build-workspace/scopes/apps/scopes/build/reports/bom.json" ]; then
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
            # Fall back to cyclonedx subdirectory if not found
            elif [ -f "/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.json" ]; then
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/cyclonedx/bom.xml"
            else
              echo "Warning: SBOM files not found in expected locations"
              SBOM_JSON_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="/c/build-workspace/scopes/apps/scopes/build/reports/bom.xml"
            fi
          else
            # Check for SBOM files in the default location first
            if [ -f "apps/scopes/build/reports/bom.json" ]; then
              SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
            # Fall back to cyclonedx subdirectory if not found
            elif [ -f "apps/scopes/build/reports/cyclonedx/bom.json" ]; then
              SBOM_JSON_PATH="apps/scopes/build/reports/cyclonedx/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/cyclonedx/bom.xml"
            else
              echo "Warning: SBOM files not found in expected locations"
              SBOM_JSON_PATH="apps/scopes/build/reports/bom.json"
              SBOM_XML_PATH="apps/scopes/build/reports/bom.xml"
            fi
          fi

          if [ -f "$SBOM_JSON_PATH" ]; then
            cp "$SBOM_JSON_PATH" "sbom-${{ matrix.platform }}-${{ matrix.arch }}.json"
          fi

          if [ -f "$SBOM_XML_PATH" ]; then
            cp "$SBOM_XML_PATH" "sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml"
          fi

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: sbom-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            sbom-${{ matrix.platform }}-${{ matrix.arch }}.json
            sbom-${{ matrix.platform }}-${{ matrix.arch }}.xml


      - name: Upload hash artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: hashes-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            hashes.txt
            hashes-b64-${{ matrix.platform }}-${{ matrix.arch }}.txt
            binary-hash-${{ matrix.platform }}-${{ matrix.arch }}.txt

  collect-hashes:
    name: Collect Hashes for SLSA
    runs-on: ubuntu-latest
    needs: build-release
    outputs:
      hashes: ${{ steps.collect.outputs.hashes }}

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Download all hash artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          pattern: hashes-*
          path: all-hashes

      - name: Collect all hashes
        id: collect
        run: |
          set -euo pipefail
          echo "Collecting hashes from all platforms..."

          # List all downloaded files for debugging
          echo "Downloaded artifacts structure:"
          find all-hashes -name "*.txt" -type f | sort

          # Combine all hash files from all platforms, decoding individual hashes
          echo "Combining hashes from all platforms..."

          # Initialize the combined hashes file
          > combined-hashes.txt

          # Process all hashes-b64-*.txt files dynamically
          first=true
          for hash_file in all-hashes/*/hashes-b64-*.txt; do
            if [ -f "$hash_file" ]; then
              echo "Processing: $hash_file"

              # Add newline separator between files (except for first file)
              if [ "$first" = false ]; then
                echo "" >> combined-hashes.txt
              fi
              first=false

              # Decode each hash and append to combined file
              while IFS=' ' read -r encoded_hash filename; do
                decoded_hash=$(echo -n "$encoded_hash" | base64 -d)
                echo "$decoded_hash $filename" >> combined-hashes.txt
              done < "$hash_file"
            fi
          done

          # Create base64 encoded string for SLSA (sha256sum format)
          HASHES_B64=$(cat combined-hashes.txt | base64 -w0)
          echo "hashes=$HASHES_B64" >> $GITHUB_OUTPUT

          echo "Collected hashes (pre-base64):"
          cat combined-hashes.txt

          echo "Collected hashes (readable):"
          cat all-hashes/*/hashes.txt

          echo "Base64 encoded for SLSA:"
          echo "$HASHES_B64"

  provenance:
    name: Generate SLSA Provenance
    needs: [build-release, collect-hashes]
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@f7dd8c54c2067bafc12ca7a55595d5ee9b75204a # v2.1.0
    with:
      base64-subjects: "${{ needs.collect-hashes.outputs.hashes }}"
      upload-assets: true

  create-unified-package:
    name: Create Unified Distribution Package
    runs-on: ubuntu-latest
    needs: [build-release, provenance]
    if: always() && needs.build-release.result == 'success'

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          elif [ "${{ github.event_name }}" = "workflow_call" ]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix for SemVer compatibility (v1.0.0 -> 1.0.0)
          CLEAN_VERSION=${VERSION#v}
          echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          path: artifacts

      - name: Download all SBOM artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          pattern: sbom-*
          path: sbom-artifacts
          merge-multiple: true

      - name: Download SLSA provenance
        if: needs.provenance.result == 'success'
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: "${{ needs.provenance.outputs.provenance-name }}"
          path: provenance

      # Note: slsa-verifier is not included in the package
      # Users should install it separately if SLSA verification is needed
      # This keeps the package size reasonable and respects the independence of the slsa-verifier project

      - name: Create unified package structure
        run: |
          PACKAGE_NAME="scopes-${{ steps.version.outputs.version }}-dist"
          mkdir -p "${PACKAGE_NAME}"
          cd "${PACKAGE_NAME}"
          
          # Create directory structure
          mkdir -p binaries verification sbom docs
          
          # Copy binaries
          find ../artifacts -name "scopes-*" -type f -not -name "*.txt" -exec cp {} binaries/ \;
          
          # Copy hash files
          find ../artifacts -name "binary-hash-*.txt" -type f -exec cp {} verification/ \;
          
          # Copy SLSA provenance if available
          if [ -d "../provenance" ]; then
            find ../provenance -name "*.intoto.jsonl" -type f -exec cp {} verification/multiple.intoto.jsonl \;
          fi
          
          # Copy SBOM files
          find ../sbom-artifacts -name "sbom-*.json" -type f -exec cp {} sbom/ \;
          find ../sbom-artifacts -name "sbom-*.xml" -type f -exec cp {} sbom/ \;
          
          # Copy installation scripts and documentation
          cp ../install/offline/README.md .
          cp ../install/offline/install.sh .
          
          # Create additional documentation
          cat > docs/INSTALL.md << 'EOF'
          # Scopes Offline Installation Guide
          
          This guide provides detailed instructions for installing Scopes from the offline distribution package.
          
          ## Prerequisites
          
          ### Linux/macOS
          - `bash` shell
          - `sha256sum` or `shasum` (for hash verification)
          - `tar` and `gzip` (for package extraction)
          
          ### Windows
          - PowerShell 5.1 or later
          - `certutil` (built into Windows)
          - Archive extraction utility (built into Windows 10/11)
          
          ## Installation Process
          
          1. Extract the offline package
          2. Run the installation script
          3. Verify the installation
          
          For detailed steps, see the main README.md file.
          EOF
          
          cat > docs/SECURITY.md << 'EOF'
          # Security Verification Guide
          
          The Scopes offline package includes multiple layers of security verification:
          
          ## Hash Verification
          
          SHA256 hashes for all binaries are included and automatically verified during installation.
          
          ## SLSA Provenance
          
          SLSA Level 3 provenance provides cryptographic proof of the build process integrity.
          
          ## Manual Verification
          
          You can manually verify any binary using the included tools and verification files.
          
          For complete security procedures, refer to the main project documentation.
          EOF
          
          cat > docs/ENTERPRISE.md << 'EOF'
          # Enterprise Deployment Guide
          
          This guide covers enterprise-specific deployment scenarios for Scopes.
          
          ## Air-Gapped Environments
          
          The offline package is designed to work in completely disconnected environments.
          
          ## Compliance Requirements
          
          SBOM files are included in CycloneDX format for dependency tracking and compliance.
          
          ## Security Scanning
          
          All binaries can be scanned with standard enterprise security tools.
          EOF
          
          # Create PowerShell installation script
          cat > install.ps1 << 'EOF'
          # Scopes Offline Installation Script for Windows PowerShell
          # This script installs Scopes from a pre-downloaded offline package
          
          param(
              [string]$InstallDir = "$env:ProgramFiles\Scopes\bin",
              [switch]$Force,
              [switch]$SkipVerification,
              [switch]$Verbose,
              [switch]$Help
          )
          
          if ($Help) {
              Write-Host "Scopes Offline Installation Script for Windows"
              Write-Host ""
              Write-Host "Parameters:"
              Write-Host "  -InstallDir      Installation directory (default: $env:ProgramFiles\Scopes\bin)"
              Write-Host "  -Force           Skip confirmation prompts"
              Write-Host "  -SkipVerification Skip security verification (not recommended)"
              Write-Host "  -Verbose         Enable verbose output"
              Write-Host "  -Help            Show this help message"
              Write-Host ""
              Write-Host "Examples:"
              Write-Host "  .\install.ps1"
              Write-Host "  .\install.ps1 -InstallDir 'C:\Tools\Scopes' -Verbose"
              Write-Host "  .\install.ps1 -Force -InstallDir 'C:\Tools\Scopes'"
              exit 0
          }
          
          Write-Host "Scopes Offline Installation for Windows" -ForegroundColor Blue
          Write-Host "This feature will be implemented in a future update." -ForegroundColor Yellow
          Write-Host "For now, please use the manual installation process:" -ForegroundColor Yellow
          Write-Host "1. Copy the appropriate binary from binaries\ to your desired location" -ForegroundColor Yellow
          Write-Host "2. Add the directory to your PATH" -ForegroundColor Yellow
          Write-Host "3. Run 'scopes --version' to verify installation" -ForegroundColor Yellow
          EOF
          
          # List package contents
          echo "Package contents:"
          find . -type f | sort

      - name: Create distribution package archives
        run: |
          PACKAGE_NAME="scopes-${{ steps.version.outputs.version }}-dist"
          
          # Create tar.gz archive
          tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}"
          
          # Create zip archive for Windows users
          zip -r "${PACKAGE_NAME}.zip" "${PACKAGE_NAME}"
          
          # Generate checksums
          sha256sum "${PACKAGE_NAME}.tar.gz" > "${PACKAGE_NAME}.tar.gz.sha256"
          sha256sum "${PACKAGE_NAME}.zip" > "${PACKAGE_NAME}.zip.sha256"
          
          echo "Created offline packages:"
          ls -la *.tar.gz *.zip *.sha256

      - name: Upload distribution package artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: distribution-packages
          path: |
            scopes-*.tar.gz
            scopes-*.zip
            scopes-*.sha256

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [build-release, provenance, create-unified-package]
    if: always() && needs.build-release.result == 'success'

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Extract version from tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.tag }}"
          elif [ "${{ github.event_name }}" = "workflow_call" ]; then
            VERSION="${{ inputs.tag }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix for SemVer compatibility (v1.0.0 -> 1.0.0)
          CLEAN_VERSION=${VERSION#v}
          echo "version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
          echo "tag_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          path: artifacts

      - name: Download all SBOM artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          pattern: sbom-*
          path: sbom-artifacts
          merge-multiple: true

      - name: Download distribution packages
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: distribution-packages
          path: distribution-packages

      - name: Download SLSA provenance
        if: needs.provenance.result == 'success'
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: "${{ needs.provenance.outputs.provenance-name }}"
          path: provenance

      - name: Display downloaded artifacts
        run: find artifacts -type f -name "*" | head -20

      - name: Generate enhanced release notes
        id: release_notes
        run: |
          # Generate release notes with verification instructions
          cat > release_notes.md << 'EOF'
          ## ðŸ” Verification Instructions
          > **Security Notice**: This release is signed and includes SLSA provenance for supply chain security.

          ### Quick Verification
          ```bash
          # Download and verify in one command
          curl -sSL https://raw.githubusercontent.com/kamiazya/scopes/main/install/install.sh | bash
          ```

          ### Manual Verification
          For detailed verification instructions, see our [Security Verification Guide](./docs/explanation/security/security-verification.md).

          ## ðŸ“¦ Artifacts
          - Binary downloads include SHA-256 checksums
          - SLSA Level 3 provenance attached
          - SBOM files available in CycloneDX format

          ## ðŸ“š Documentation
          - [Installation Guide](./install/README.md)
          - [Security Verification](./docs/explanation/security/security-verification.md)
          - [SBOM Verification](./docs/explanation/security/sbom-verification.md)
          EOF

          # Store the custom content
          {
            echo "custom_content<<EOF"
            cat release_notes.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Create or update GitHub Release with auto-generated notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Generate release notes using GitHub API
          NOTES=$(gh api repos/${{ github.repository }}/releases/generate-notes \
            -f tag_name='${{ steps.version.outputs.tag_version }}' \
            --jq .body)
          
          # Create or update release without destructive deletion
          if ! gh release view "${{ steps.version.outputs.tag_version }}" > /dev/null 2>&1; then
            gh release create "${{ steps.version.outputs.tag_version }}" \
              --title "Release ${{ steps.version.outputs.version }}" \
              --notes "$NOTES" \
              --prerelease=${{ contains(steps.version.outputs.tag_version, '-') }}
          else
            gh release edit "${{ steps.version.outputs.tag_version }}" --notes "$NOTES"
          fi

      - name: Upload release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Upload all binary artifacts
          find artifacts -name "scopes-*" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;

          # Upload hash files
          find artifacts -name "binary-hash-*.txt" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;

          # Upload SBOM files
          find sbom-artifacts -name "sbom-*.json" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;
          find sbom-artifacts -name "sbom-*.xml" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;

          # Upload distribution packages
          find distribution-packages -name "scopes-*-dist.tar.gz" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;
          find distribution-packages -name "scopes-*-dist.zip" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;
          find distribution-packages -name "scopes-*-dist.*.sha256" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;

          # Upload SLSA provenance if available
          if [ -d "provenance" ] && [ -n "$(find provenance -name "*.intoto.jsonl" -type f)" ]; then
            find provenance -name "*.intoto.jsonl" -type f -exec gh release upload "${{ steps.version.outputs.tag_version }}" --clobber {} \;
          fi

      - name: Enhance release notes with custom content
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the auto-generated release notes
          AUTO_NOTES=$(gh release view "${{ steps.version.outputs.tag_version }}" --json body --jq '.body')

          # Create the combined release notes
          cat > combined_notes.md << 'EOF'
          ${{ steps.release_notes.outputs.custom_content }}

          ## Installation

          ### ðŸš€ Quick Install (Recommended)

          #### Linux/macOS
          ```bash
          curl -sSL https://raw.githubusercontent.com/kamiazya/scopes/main/install/install-unified.sh | sh
          ```

          #### Windows PowerShell
          ```powershell
          iwr https://raw.githubusercontent.com/kamiazya/scopes/main/install/install.ps1 | iex
          ```

          ### ðŸ“¦ Offline Installation

          For air-gapped environments or enterprise deployments, download the unified distribution package:

          1. Download `scopes-${{ steps.version.outputs.version }}-dist.tar.gz` or `.zip`
          2. Extract the package
          3. Run `./install.sh` (Unix) or `.\install.ps1` (Windows)

          The offline package includes:
          - All platform binaries (Linux, macOS, Windows - x64 & ARM64)
          - Security verification (SHA256 hashes + SLSA provenance)
          - Complete documentation
          - SBOM files for compliance

          ### Manual Binary Installation

          Individual binaries are also available for direct download below.

          #### Linux/macOS
          ```bash
          chmod +x scopes-*
          sudo mv scopes-* /usr/local/bin/scopes
          ```

          #### Windows
          Extract `scopes-*.exe` to a directory in your PATH.

          ## Security & Verification

          This release includes SLSA Level 3 provenance and Software Bill of Materials (SBOM) for comprehensive supply chain security.

          ### SLSA Provenance Verification
          ```bash
          # Install slsa-verifier
          go install github.com/slsa-framework/slsa-verifier/v2/cli/slsa-verifier@latest

          # Verify the binary (example for Linux)
          slsa-verifier verify-artifact scopes-${{ steps.version.outputs.version }}-linux-x64 \
            --provenance-path multiple.intoto.jsonl \
            --source-uri github.com/${{ github.repository }}
          ```

          ### SBOM (Software Bill of Materials)

          Each platform includes SBOM files in both industry-standard formats:
          - **CycloneDX** (JSON/XML): Security-focused with vulnerability tracking capabilities
          - Download: `sbom-{platform}-{arch}.json` or `sbom-{platform}-{arch}.xml`

          #### SBOM Usage Examples
          ```bash
          # Analyze dependencies with CycloneDX tools
          cyclonedx-cli analyze sbom-linux-x64.json

          # Import into OWASP Dependency-Track
          curl -X POST "http://dtrack-server/api/v1/bom" \
            -H "X-API-Key: your-api-key" \
            -H "Content-Type: application/json" \
            -d @sbom-linux-x64.json
          ```

          ### Manual Verification
          See the checksums in `binary-hash-*.txt` files for manual verification of binaries.
          EOF

          # Add the auto-generated notes after our custom content
          echo "" >> combined_notes.md
          echo "$AUTO_NOTES" >> combined_notes.md

          # Update the release with combined content
          gh release edit "${{ steps.version.outputs.tag_version }}" --notes-file combined_notes.md
